# 流量控制

**滑动窗口发送数据**
- 发送窗口：发送窗口内的数据的可连续的发送出去，而不需要等待对方的确认（从而提高信道利用率）

- 滑动窗口：发送方每收到一个接受确认，就将发送窗口的向前滑动一个字节的位置；

接收方采用积累确认的方式（对有序的几个分组只确认最后一个分组）
TCP的滑动窗口是以字节为单位的；

# 拥塞控制

从控制理论的角度来看拥塞控制这个问题，可以分为开环控制和闭环控制两种方法。开环控制就是在设计网络时事先将有关拥塞发生的所有因素考虑周到，一旦系统运行起来就不能在中途改正。闭环控制是基于反馈环路的概念，包括如下措施：
1. 监测网路系统以便检测拥塞在何时、何地发生
1. 把拥塞发生的信息传送到可采取行动的地方
1. 调整网络系统的行动以解决出现的问题。
1. 拥塞控制方法

因特网建议标准RFC2581定义了进行拥塞控制的四种算法，即慢开始（Slow-start)、拥塞避免（Congestion Avoidance)、快重传（Fast Restrangsmit)和快回复（Fast Recovery）。

**假定:**
1. 数据是单方向传送，而另外一个方向只传送确认
1. 接收方总是有足够大的缓存空间，因为发送窗口的大小由网络的拥塞程度来决定。


## 慢开始和拥塞避免

发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就增大一些，以便把更多的分组发送出去。但是只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络的分组数。

慢开始算法的思路就是：最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生。具体来说，当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加至多1个MSS大小。用这样的方法来逐步增大拥塞窗口CWND。

为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：
- 当cwnd < ssthresh时，使用慢开始算法。
- 当cwnd > ssthresh时，改用拥塞避免算法。
- 当cwnd = ssthresh时，慢开始与拥塞避免算法任意。

**拥塞避免算法思路：** 

让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。

![](https://github.com/skittlekx/JAVA_NOTE/blob/22268d6e48427d832c4fa5242aea69b31c99be9e/img/%E6%85%A2%E5%BC%80%E5%A7%8B%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png?raw=true)


## 快重传和快恢复

一条TCP连接有时会因等待重传计时器的超时而空闲较长的时间，慢开始和拥塞避免无法很好的解决这类问题，因此提出了快重传和快恢复的拥塞控制方法。快重传算法并非取消了重传机制，只是在某些情况下更早的重传丢失的报文段（如果当发送端接收到三个重复的确认ACK时，则断定分组丢失，立即重传丢失的报文段，而不必等待重传计时器超时）。

快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

快重传配合使用的还有快恢复算法，有以下两个要点:

1. 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并**不执行慢开始**算法。
1. 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh减半后的大小，然后执行拥塞避免算法。

![](https://github.com/skittlekx/JAVA_NOTE/blob/22268d6e48427d832c4fa5242aea69b31c99be9e/img/TCP%E5%BF%AB%E6%81%A2%E5%A4%8D.png?raw=true)


**随机早期检测RED：**

以上的拥塞避免算法并没有和网络层联系起来，实际上网络层的策略对拥塞避免算法影响最大的就是路由器的丢弃策略。在简单的情况下路由器通常按照先进先出的策略处理到来的分组。当路由器的缓存装不下分组的时候就丢弃到来的分组，这叫做尾部丢弃策略。这样就会导致分组丢失，发送方认为网络产生拥塞。更为严重的是网络中存在很多的TCP连接，这些连接中的报文段通常是复用路由路径。若发生路由器的尾部丢弃，可能影响到很多条TCP连接，结果就是这许多的TCP连接在同一时间进入慢开始状态。这在术语中称为全局同步。全局同步会使得网络的通信量突然下降很多，而在网络恢复正常之后，其通信量又突然增大很多。

为避免发生网路中的全局同步现象，路由器采用随机早期检测(RED:randomearly detection)。该算法要点如下：

使路由器的队列维持两个参数，即队列长队最小门限min和最大门限max，每当一个分组到达的时候，RED就计算平均队列长度。然后分情况对待到来的分组：

1. 平均队列长度小于最小门限——把新到达的分组放入队列排队。

1. 平均队列长度在最小门限与最大门限之间——则按照某一概率将分组丢弃。

1. 平均队列长度大于最大门限——丢弃新到达的分组。


RED不是等到已经发生拥塞后才把所有队列尾部的分组全部丢弃，而是在检测到网络拥塞的早期征兆时（即路由器的平均队列长度超过一定门限值时），以概率p随机丢弃分组，让拥塞控制只在个别的TCP连接上执行，因而避免全局性的拥塞控制。

RED的关键就是选择三个参数最小门限、最大门限、丢弃概率和计算平均队列长度。最小门线必须足够大，以保证路由器的输出链路有较高的利用率。而最大门限和最小门限只差也应该足够大，是的在一个TCP往返时间RTT中队列的正常增长仍在最大门限之内。经验证明：使最大门限等于最小门限的二倍是合适的。

平均队列长度采用加权平均的方法计算平均队列长度，这和往返时间（RTT）的计算策略是一样的。

![](https://github.com/skittlekx/JAVA_NOTE/blob/7955da6bc1c232ea4c3ea8d2840593f2f0b5b442/img/RED%E5%88%86%E7%BB%84%E4%B8%A2%E5%BC%83%E6%A6%82%E7%8E%87.png?raw=true)

![](https://github.com/skittlekx/JAVA_NOTE/blob/7955da6bc1c232ea4c3ea8d2840593f2f0b5b442/img/RED%E9%A1%BA%E5%8A%BF%E9%98%9F%E5%88%97%E9%95%BF%E5%BA%A6%E5%92%8C%E5%B9%B3%E5%9D%87%E9%98%9F%E5%88%97%E9%95%BF%E5%BA%A6.png?raw=true)